# Manual Extension

This directory contains the files for building the Angles module by
[extending Python](https://docs.python.org/2/extending/extending.html)
"manually".

- **Makefile** creates the Python module and runs the test scripts.
- **gen_angles_module.py** generates angles.cpp. This removes the redundancy of creating wrappers for each template instantiation and creates angles.cpp with the python wrappers.
- **gen_test_angles.py** generates the unit test file test_angles.py
- **pylaunch.sh** sets up the Python environment and returns a Python command line interpreter.
- **setenv.sh** sets up the Python environment.
- **setup.py** builds the angles module from angles.cpp (generated by gen_angles_module.py).
- **test_angles.sh** sets up the Python environment and runs the unit tests.


# Exceptions

This module has its own angles.Error exceptions. Boost uses
RuntimeError to wrap the C++ Exceptions.

# Class vs. Template

There are two types of objects wrapped, the Angle class and
LimitedRangeAngle templates. Deep in the arithmetic operators, +, -,
*, /, I found an undocumented feature: The Angle class can construct
the result using the copy constructor, (e.g. + and -) or the copy
assign constructor (e.g. * and /), but the template versions can
not.

In the class version I can build the m_angle struct from the
class objects:

```
    result_angle->m_angle = ((Angle*)o1)->m_angle / ((Angle*)o2)->m_angle;
```

This causes range exceptions when I try it with the tempalte forms.
I work around the problem by constructing from the values:

```
      Angles::LimitedRangeAngle the_quotient(((LimitedRangeAngle*)o1)->m_angle.value() /
					     ((LimitedRangeAngle*)o2)->m_angle.value());
```

I also found that the m_angle object's methods always return zero in the
python wrapper context:

```
static int LimitedRangeAngle_init(LimitedRangeAngle* self, PyObject* args, PyObject* kwds) {

  double degrees(0);
  double minutes(0);
  double seconds(0);

  static char* kwlist[] = {sDegreeStr, sMinuteStr, sSecondStr, NULL};

  if (! PyArg_ParseTupleAndKeywords(args, kwds, "|ddd", kwlist, &degrees, &minutes, &seconds))
    return -1;

  double a_value(Angles::degrees2seconds(degrees, minutes, seconds)/3600);

  // Angles::LimitedRangeAngle an_angle(a_value); // hi error works with this out

  std::cout << "not valid range " << self->m_angle.isValidRange(a_value)
   << " value " << a_value
   << " a value " << self->m_angle.value()
   << " max " << self->m_angle.maximum()
   << " min " << self->m_angle.minimum()
   << std::endl;

  if (self->m_angle.isValidRange(a_value) == true) {

    std::stringstream emsg;
    emsg << "not valid range " << a_value;

    PyErr_SetString(sAngleException, emsg.str().c_str());
    return -1;
  }

  self->m_angle.value(a_value);

  std::cout << "not valid range " << self->m_angle.isValidRange(a_value)
   << " value " << a_value
   << " a value " << self->m_angle.value()
   << " max " << self->m_angle.maximum()
   << " min " << self->m_angle.minimum()
   << std::endl;


  return 0;
}

```

produces

```
$ ./pylaunch.sh test_angles.py TestLimitedRangeAngle.test_construct_degrees

not valid range 0 value -129.282 a value 0 max 0 min 0
not valid range 0 value -129.282 a value -129.282 max 0 min 0
```

I am still working out why this is so.
